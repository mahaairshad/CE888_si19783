# -*- coding: utf-8 -*-
"""DSDM_Ass2_3of3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GapHkqepfIpmb7km-tWIlpe9xEFRnbNy
"""

# ********************************** Assignment 2 ************************************
# ----------------------------------- Part (3/3) -------------------------------------
#
# This code evaluates the performance of the agents in 20 vs. 20 agents' match in Python 3.0.
# 
# A 2-player tic-tac-toe game is played using UCTPlayGame() function based on the trained agents.
# A total of 1000(5x200) games are played among each competitors.
# The win-rates and draw-rates are stored in separate .csv files.
# 
# Written by Shahzadi Mahaa Irshad 
# Reg ID: 1901079
# CSEE, University of Essex
# Submiteed as part of the requirements for CE888- Data Science and Decision Making
# Date: 19-4-2020
# 
# For more information about the program please read the report available in the repository.

from math import *
import random
import numpy as np
import pandas as pd
from sklearn import tree


def DecisionTreeFit(x,y):
  """ Trains a DT-based classifier.
  """
  clf = tree.DecisionTreeClassifier()
  clf = clf.fit(x, y)
  return clf


def getXY(df,clf):
  """ Separates data and labels to train a DT-based classifier.
  """
  Y=df['Move']
  Y=Y.astype(dtype='int32')
  X=df.drop(columns='Move')
  X=X.astype(dtype='int32')
  dictOfPlayers[clf]=DecisionTreeFit(X,Y)


def DecisionTreePred(clf, x):
  """ Make a prediction for x using clf provided.
  """
  y=clf.predict(x)
  if x[0,y[0]]!=0: # if the move predicted is not available
    emp_ind=np.array(np.where(x[0,:]==0)) # find all the empty boxes
    y[0]=np.random.choice(emp_ind[0,:]) # select any random index from the available empty options
  return y[0]


def ChangePlyrRep(s):
  """ Change the notation for players. Replace '1' by '2', and '2' by '1'.
      This is done to save the representation of player 2 to 1 as 
      the dataset produced contains best moves for the player with 
      notation '1', representing the current player. 
      The opponent is always '2' in the dataset.
  """
  s1 = np.array(s,dtype='int32')
  p2_ind=np.where(s1==2)
  p1_ind=np.where(s1==1)
  s1[p2_ind]=1
  s1[p1_ind]=2
  return s1


class GameState:
    """ A state of the game, i.e. the game board. These are the only functions which are
        absolutely necessary to implement UCT in any 2-player complete information deterministic 
        zero-sum game, although they can be enhanced and made quicker, for example by using a 
        GetRandomMove() function to generate a random move during rollout.
        By convention the players are numbered 1 and 2.
    """
    def __init__(self):
            self.playerJustMoved = 2
        
    def Clone(self):
        """ Create a deep clone of this game state.
        """
        st = GameState()
        st.playerJustMoved = self.playerJustMoved
        return st

    def DoMove(self, move):
        """ Update a state by carrying out the given move.
            Must update playerJustMoved.
        """
        self.playerJustMoved = 3 - self.playerJustMoved
        
    def GetMoves(self):
        """ Get all possible moves from this state.
        """
    
    def GetResult(self, playerjm):
        """ Get the game result from the viewpoint of playerjm. 
        """

    def __repr__(self):
        """ Don't need this - but good style.
        """
        pass


class OXOState:
    """ A state of the game, i.e. the game board.
        Squares in the board are in this arrangement
        012
        345
        678
        where 0 = empty, 1 = player 1 (X), 2 = player 2 (O)
    """
    def __init__(self):
        self.playerJustMoved = np.random.randint(1,3) # The player for first move is randomly selected
        self.board = [0,0,0,0,0,0,0,0,0] # 0 = empty, 1 = player 1, 2 = player 2
        
    def Clone(self):
        """ Create a deep clone of this game state.
        """
        st = OXOState()
        st.playerJustMoved = self.playerJustMoved
        st.board = self.board[:]
        return st

    def DoMove(self, move):
        """ Update a state by carrying out the given move.
            Must update playerToMove.
        """
        assert move >= 0 and move <= 8 and move == int(move) and self.board[move] == 0
        self.playerJustMoved = 3 - self.playerJustMoved
        self.board[move] = self.playerJustMoved
        
    def GetMoves(self):
        """ Get all possible moves from this state.
        """
        return [i for i in range(9) if self.board[i] == 0]
    
    def GetResult(self, playerjm):
        """ Get the game result from the viewpoint of playerjm. 
        """
        for (x,y,z) in [(0,1,2),(3,4,5),(6,7,8),(0,3,6),(1,4,7),(2,5,8),(0,4,8),(2,4,6)]:
            if self.board[x] == self.board[y] == self.board[z]:
                if self.board[x] == playerjm:
                    return 1.0
                else:
                    return 0.0
        if self.GetMoves() == []: return 0.5 # draw
        return False # Should not be possible to get here

    def __repr__(self):
        s= ""
        for i in range(9): 
            s += ".XO"[self.board[i]]
            if i % 3 == 2: s += "\n"
        return s


def UCTPlayGame(clfA,clfB):
    """ Play a sample game between two UCT players where each player gets a different number 
        of UCT iterations (= simulations = tree nodes).
    """
    global draws
    global wins1
    global wins2
    
    state = OXOState()
    while state.GetMoves() != []:
      print(str(state))
      cur_state=np.asarray(state.board,dtype='int32')
      cur_state=cur_state.reshape(1,9)

      if len(state.GetMoves())==9:
        m=random.choice(state.GetMoves())

      else:
        if state.playerJustMoved == 1:
            cur_state=ChangePlyrRep(cur_state)
            m = DecisionTreePred(clfA, cur_state)
        else:
            m = DecisionTreePred(clfB, cur_state)
      
      print("Move: " + str(m) + "\n")
      state.DoMove(m)

      if state.GetResult(state.playerJustMoved) != False:
          print(str(state))
          break
  
    # Finding the player that won.
    if state.GetResult(state.playerJustMoved) == 1.0: # checking if the last player won or not
        Winner= int(state.playerJustMoved) 
        print("Player 1" + " wins!")
        if state.playerJustMoved==1: wins1=wins1+1
        else: wins2=wins2+1
    elif state.GetResult(state.playerJustMoved) == 0.0: # checking if the last player lost or not
        Winner= int(state.playerJustMoved) 
        print("Player 2" + " wins!")
        if state.playerJustMoved==1: wins1=wins1+1
        else: wins2=wins2+1
    else:
        Winner=0 # Match draw
        print("Nobody wins!")
        draws=draws+1


if __name__ == "__main__":
    """ Play 1000 games to the end using DT-based agents for both players. 
    """
    dictOfPlayers = {} # Make a Dictionary
    player=['clf1','clf2','clf3','clf4','clf5','clf6','clf7','clf8','clf9','clf10',
            'clf11','clf12','clf13','clf14','clf15','clf16','clf17','clf18','clf19','clf20'] # List of the players

    # Load datasets
    df1= pd.read_csv('/content/Dataset_for_'+player[0]+'.csv')
    df2= pd.read_csv('/content/Dataset_for_'+player[1]+'.csv')
    df3= pd.read_csv('/content/Dataset_for_'+player[2]+'.csv')
    df4= pd.read_csv('/content/Dataset_for_'+player[3]+'.csv')
    df5= pd.read_csv('/content/Dataset_for_'+player[4]+'.csv')
    df6= pd.read_csv('/content/Dataset_for_'+player[5]+'.csv')
    df7= pd.read_csv('/content/Dataset_for_'+player[6]+'.csv')
    df8= pd.read_csv('/content/Dataset_for_'+player[7]+'.csv')
    df9= pd.read_csv('/content/Dataset_for_'+player[8]+'.csv')
    df10= pd.read_csv('/content/Dataset_for_'+player[9]+'.csv')
    df11= pd.read_csv('/content/Dataset_for_'+player[10]+'.csv')
    df12= pd.read_csv('/content/Dataset_for_'+player[11]+'.csv')
    df13= pd.read_csv('/content/Dataset_for_'+player[12]+'.csv')
    df14= pd.read_csv('/content/Dataset_for_'+player[13]+'.csv')
    df15= pd.read_csv('/content/Dataset_for_'+player[14]+'.csv')
    df16= pd.read_csv('/content/Dataset_for_'+player[15]+'.csv')
    df17= pd.read_csv('/content/Dataset_for_'+player[16]+'.csv')
    df18= pd.read_csv('/content/Dataset_for_'+player[17]+'.csv')
    df19= pd.read_csv('/content/Dataset_for_'+player[18]+'.csv')
    df20= pd.read_csv('/content/Dataset_for_'+player[19]+'.csv')
    
    df=[df1,df2,df3,df4,df5,df6,df7,df8,df9,df10,
        df11,df12,df13,df14,df15,df16,df17,df18,df19,df20]
    
    for i in range (20): # Train all agents
      getXY(df[i],player[i])

    draws=0
    wins1=0
    wins2=0
    t_wins=0
    t_draws=0
    win_results=np.empty((20,20))
    draw_results=np.empty((20,20))

    for i in range (20):
      for j in range (20):
        for l in range (5): # play 200 games for 5 iterations-> total 1000 games
          for k in range (0,200): # 200 games
            clfA=dictOfPlayers[player[i]]
            clfB=dictOfPlayers[player[j]]
            UCTPlayGame(clfA,clfB)
          if player[i]==player[j]:
            if wins1<wins2:wins1=wins2 # if the agent plays against itself, consider the higher winrate
          t_wins+=(wins1/200*100) # winrate is being calculated for player 1
          t_draws+=(draws/200*100)
          draws=0
          wins1=0
          wins2=0
        # Taking mean of 5 iterations
        win_results[i][j]=np.around((t_wins/5),decimals=2)
        draw_results[i][j]=np.around((t_draws/5),decimals=2)
        t_wins=0
        t_draws=0

    # Export evaluation results
    df_win= pd.DataFrame(data=win_results, index=player, columns=player)
    df_draw= pd.DataFrame(data=draw_results, index=player, columns=player)
    df_win.to_csv('Win_rate.csv')
    df_draw.to_csv('Draw_rate.csv')

    # A visual comparison of win and draw rates
    d=np.empty((20,20),dtype='object')
    for i in range (20):
      for j in range (20):
        d[i][j]=str(win_results[i][j])+' | '+str(draw_results[i][j])
    df_results= pd.DataFrame(data=d, index=player, columns=player)
    df_results.to_csv('Win|Draws_rate.csv')